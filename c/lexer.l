%{
#include "compile.h"
#include "parser.tab.h"  /* Generated by bison. */

#define YY_USER_ACTION                           \
  do {                                           \
    yylloc->start = yyget_extra(yyscanner);      \
    yylloc->end = yylloc->start + yyleng;        \
    yyset_extra(yylloc->end, yyscanner);         \
  } while (0);

%}

%option noyywrap nounput noinput nodefault
%option reentrant
%option extra-type="int"
%option bison-bridge bison-locations
%option prefix="jq_yy"

%%

"==" { return EQ; }
"as" { return AS; }
"def" { return DEF; }
"if" { return IF; }
"then" { return THEN; }
"else" { return ELSE; }
"elif" { return ELSE_IF; }
"and" { return AND; }
"or" { return OR; }
"not" { return NOT; }
"end" { return END; }
"//" { return DEFINEDOR; }
"|=" { return SETPIPE; }
"+=" { return SETPLUS; }
"-=" { return SETMINUS; }
"*=" { return SETMULT; }
"/=" { return SETDIV; }
"//=" { return SETDEFINEDOR; }
"."|"="|";"|"["|"]"|","|":"|"("|")"|"{"|"}"|"|"|"+"|"-"|"*"|"/"|"\$" { return yytext[0];}

\"(\\.|[^\\\"])*\" |
-?[0-9.]+([eE][+-]?[0-9]+)? { 
   yylval->literal = jv_parse_sized(yytext, yyleng); return LITERAL; 
}

\"(\\.|[^\\\"])* { 
  yylval->literal = jv_invalid_with_msg(jv_string("Unterminated string"));
  return LITERAL;
}
  

[[:alnum:]]+  { yylval->literal = jv_string(yytext); return IDENT;}

[ \n\t]+  {}

. { return INVALID_CHARACTER; }

%%
/* perhaps these should be calls... */
/*
"true" { return TRUE; }
"false" { return FALSE; }
"null" { return NULL; }
*/
